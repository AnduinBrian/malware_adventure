from unicorn import *
from unicorn.x86_const import *

ADDRESS = 0x401000
STACK = 0x100000
COMPRESSED = 0x500000
OUTPUT = 0x700000

def hook_code(uc, address, size, userdata):
    if (uc.reg_read(UC_X86_REG_EDI) - OUTPUT) == 0x5400 :
        print("Done !!")
        a = uc.mem_read(OUTPUT,0x5400)
        temp = b""
        for i in a:
            temp += i.to_bytes(1, "little")
        with open("dump_result.bin", "wb") as file:
            file.write(temp)
        uc.emu_stop() 
            

data = get_bytes(0x4053E3, 0x2fde)

code = get_bytes(0x401000, 0x409000 - 0x401000) # start and end of .text seg

mu = Uc(UC_ARCH_X86, UC_MODE_32)
mu.mem_map(ADDRESS, 0x8000)
mu.mem_map(STACK, 0x10000)
mu.mem_map(COMPRESSED, 2 * 1024 * 1024 ) # setup data_compressed mem
mu.mem_map(OUTPUT, 100 * 0x1000) # setup data_decompress mem

mu.mem_write(ADDRESS, code) # write instruction
mu.mem_write(COMPRESSED, data) # write data
mu.mem_write(STACK + 0x5000 + 0x8, b"\x00\x00\x50\x00\x00\x00\x70\x00") #setup stack with specific value for esi, edi

# modify reg value
mu.reg_write(UC_X86_REG_ESP, STACK + 0x5000)
mu.reg_write(UC_X86_REG_EBP, STACK + 0x5000)

mu.hook_add(UC_HOOK_CODE, hook_code) # setup hook for debug and write data
mu.emu_start(ADDRESS + 0x26F, ADDRESS + 0x326) # emu from address: 0x40126f -> 0x401326 (lzsa2 function)
