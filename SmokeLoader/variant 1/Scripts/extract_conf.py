def unhex(hex_string):
    import binascii
    if type(hex_string) == str:
        return binascii.unhexlify(hex_string.encode('utf-8'))
    else:
        return binascii.unhexlify(hex_string)

def rc4crypt(data, key):
    #If the input is a string convert to byte arrays
    if type(data) == str:
        data = data.encode('utf-8')
    if type(key) == str:
        key = key.encode('utf-8')
    x = 0
    box = list(range(256))
    for i in range(256):
        x = (x + box[i] + key[i % len(key)]) % 256
        box[i], box[x] = box[x], box[i]
    x = 0
    y = 0
    out = []
    for c in data:
        x = (x + 1) % 256
        y = (y + box[x]) % 256
        box[x], box[y] = box[y], box[x]
        out.append(c ^ box[(box[x] + box[y]) % 256])
    return bytes(out)

def extract_config(startEA, size):
    data_offset = []
    offset = get_bytes(startEA, size * 8)
    for i in range(0,len(offset) -1, 8):
        a = offset[i:i+8:]
        data_offset.append(struct.unpack("<Q",a)[0])
    for i in data_offset:
        out = ""
        data_len = get_bytes(i,1)
        data_len = struct.unpack("<B",data_len)[0]
        key = get_bytes(i + 1, 4)
        data = get_bytes(i + 5, data_len)
        result = rc4crypt(data,key)
        print("".join([chr(x) for x in result]))

def decryt_single(startEA):
    data_len = get_bytes(startEA, 0x1)
    data_len = struct.unpack("<B", data_len)[0]
    key = get_bytes(startEA + 1, 4)
    data = get_bytes(startEA + 5, data_len)
    print(rc4crypt(data, key))